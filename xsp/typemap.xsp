%loadplugin{feature::default_xs_typemap};

%typemap{std::string}{parsed}{
    %xs_type{T_STD_STRING};
    %xs_input_code{%{
        $var = std::string( SvPV_nolen( $arg ), SvCUR( $arg ) );
    }%};
    %xs_output_code{%{
        $arg = newSVpvn( $var.c_str(), $var.length() );
    }%};
};

%typemap{std::vector< std::string >}{parsed}{
    %xs_type{T_STR_VEC};
    %xs_input_code{%{
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVAV))
                Perl_croak(aTHX_ \"$var is not a ArrayRef\");
        AV* av = (AV*) SvRV($arg);
        int length = AvFILL(av) + 1;
        std::vector<std::string> rvec(length);
        for (int i = 0; i < length; i++) {
            SV** el = av_fetch(av, i, 0);
            rvec.at(i) = std::string(SvPV_nolen(*el), SvCUR(*el));
        }
        $var = rvec;
    }%};
    %xs_output_code{%{
        AV* av = newAV();
        int length = $var.size();
        for (int i = 0; i < length; i++) {
            const std::string& str = $var.at(i);
            SV* val = newSVpvn( str.c_str(), str.size() );
            av_store(av, i, val);
        }
        $arg = sv_2mortal(newRV_noinc((SV*) av));
    }%};
};

%typemap{mesos::perl::ProxyScheduler*}{simple}{ 
    %name{object}; 
    %xs_type{O_PROXY_SCHEDULER}; 
    %xs_input_code{%{ 
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVHV)) 
            Perl_croak(aTHX_ \"$var is not a blessed reference of type ${ntype}\"); 
        SV* tied_hash = SvRV($arg); 
        MAGIC* ext_magic = mg_find(tied_hash, PERL_MAGIC_ext); 
        $var = ($type) ext_magic->mg_ptr; 
    }%}; 
    %xs_output_code{%{ 
        HV* stash = gv_stashpv(\"Net::Mesos::ProxyScheduler\", GV_ADDWARN); 
        SV* attr_hash = (SV*) newHV(); 
        sv_magic(attr_hash, Nullsv, PERL_MAGIC_ext, 
                         (const char*) $var, 0); 
        $arg = sv_bless(sv_2mortal(newRV_noinc(attr_hash)), stash); 
    }%}; 
};

%typemap{mesos::perl::SchedulerDriver*}{simple}{
    %name{object};
    %xs_type{O_SCHEDULER_DRIVER};
    %xs_input_code{%{ 
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVHV))
            Perl_croak(aTHX_ \"$var is not a blessed reference of type ${ntype}\"); 
        SV* tied_hash = SvRV($arg); 
        MAGIC* ext_magic = mg_find(tied_hash, PERL_MAGIC_ext); 
        $var = ($type) ext_magic->mg_ptr; 
    }%}; 
    %xs_output_code{%{ 
        HV* stash = gv_stashpv(\"Net::Mesos::SchedulerDriver\", GV_ADDWARN); 
        SV* attr_hash = (SV*) newHV(); 
        sv_magic(attr_hash, Nullsv, PERL_MAGIC_ext, 
                         (const char*) $var, 0); 
        $arg = sv_bless(sv_2mortal(newRV_noinc(attr_hash)), stash); 
    }%}; 
};

%typemap{mesos::perl::ExecutorDriver*}{simple}{
    %name{object};
    %xs_type{O_EXECUTOR_DRIVER};
    %xs_input_code{%{ 
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVHV))
            Perl_croak(aTHX_ \"$var is not a blessed reference of type ${ntype}\"); 
        SV* tied_hash = SvRV($arg); 
        MAGIC* ext_magic = mg_find(tied_hash, PERL_MAGIC_ext); 
        $var = ($type) ext_magic->mg_ptr; 
    }%}; 
    %xs_output_code{%{ 
        HV* stash = gv_stashpv(\"Net::Mesos::ExecutorDriver\", GV_ADDWARN); 
        SV* attr_hash = (SV*) newHV(); 
        sv_magic(attr_hash, Nullsv, PERL_MAGIC_ext, 
                         (const char*) $var, 0); 
        $arg = sv_bless(sv_2mortal(newRV_noinc(attr_hash)), stash); 
    }%}; 
};

%typemap{mesos::perl::MesosChannel*}{simple}{
    %name{object};
    %xs_type{O_SCHEDULER_CHANNEL};
    %xs_input_code{%{
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVGV))
            Perl_croak(aTHX_ \"$var is not a blessed reference of type ${ntype}\");
        SV* tied_glob = SvRV($arg);
        MAGIC* ext_magic = mg_find(tied_glob, PERL_MAGIC_ext);
        $var = ($type) ext_magic->mg_ptr;
    }%};
    %xs_output_code{%{
        HV* stash = gv_stashpv(\"Net::Mesos::Channel\", GV_ADDWARN);
        SV* glob = (SV*) newGVgen(\"Net::Mesos::Channel\");
        GvIOp(glob) = newIO();
        IoIFP(GvIOp(glob)) = PerlIO_importFILE($var->in_, "r");
        sv_magic(glob, Nullsv, PERL_MAGIC_ext,
                         (const char*) $var, 0);
        $arg = sv_bless(sv_2mortal(newRV_noinc(glob)), stash);
    }%};
};

%typemap{mesos::perl::ProxyExecutor*}{simple}{ 
    %name{object}; 
    %xs_type{O_PROXY_EXECUTOR}; 
    %xs_input_code{%{ 
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVHV)) 
            Perl_croak(aTHX_ \"$var is not a blessed reference of type ${ntype}\"); 
        SV* tied_hash = SvRV($arg); 
        MAGIC* ext_magic = mg_find(tied_hash, PERL_MAGIC_ext); 
        $var = ($type) ext_magic->mg_ptr; 
    }%}; 
    %xs_output_code{%{ 
        HV* stash = gv_stashpv(\"Net::Mesos::ProxyExecutor\", GV_ADDWARN); 
        SV* attr_hash = (SV*) newHV(); 
        sv_magic(attr_hash, Nullsv, PERL_MAGIC_ext, 
                         (const char*) $var, 0); 
        $arg = sv_bless(sv_2mortal(newRV_noinc(attr_hash)), stash); 
    }%}; 
};
