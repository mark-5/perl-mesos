%module{Net::Mesos};
#include <MesosChannel.hpp>
#include <XS/NetMesosUtils.hpp>


%name{Net::Mesos::Channel} class mesos::perl::MesosChannel
{

int FILENO()
    %code{%
        RETVAL = fileno(THIS->in_);
    %};

%{

static void
DESTROY(SV* self)
    PPCODE:
        // make sure the c++ destructor only gets called once
        //  (both the blessed glob and the tied hash will call DESTROY)
        if (!SvROK(self) || (SvTYPE(SvRV(self)) != SVt_PVGV))
            XSRETURN_YES;
        SV* glob = SvRV(self);
        MAGIC *tie_magic = mg_find(MUTABLE_SV(GvIOp(glob)), PERL_MAGIC_tiedscalar);
        SV* tied_hash = SvRV(tie_magic->mg_obj);
        MAGIC* ext_magic = mg_find(tied_hash, PERL_MAGIC_ext);
        mesos::perl::MesosChannel* channel = (mesos::perl::MesosChannel*) ext_magic->mg_ptr;
        delete channel;
        XSRETURN_YES;

static mesos::perl::MesosChannel*
mesos::perl::MesosChannel::new(...)
    CODE:
        RETVAL = new mesos::perl::MesosChannel;
    OUTPUT:
        RETVAL

mesos::perl::MesosCommand
mesos::perl::MesosChannel::recv()
    CODE:
        if (!THIS->pending_->size()) {
            if (GIMME_V == G_ARRAY) {
                XSRETURN_EMPTY;
            } else {
                XSRETURN_UNDEF;
            }
        }
        RETVAL = THIS->recv();
    OUTPUT:
        RETVAL

void
mesos::perl::MesosChannel::send(mesos::perl::MesosCommand command)
    PPCODE:
        THIS->send(command);
        XSRETURN_YES;
%}

};
